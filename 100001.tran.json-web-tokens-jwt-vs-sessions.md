---
来源: https://float-middle.com/json-web-tokens-jwt-vs-sessions/
原作者: Jacek Ciolek
翻译: alingse && Tobyn(mushanshitiancai)
---
 
 _Jacek_
=======

## 什么是JWT

> 本质上它是一份签名过的JSON格式数据。因为它是签名过的，所以接收方可以验证它的真实性。同时因为它是JSON格式的，所以是非常轻量的。如果你想要查看正式定义，可以参考[RFC 7519](https://tools.ietf.org/html/rfc7519)。

签名数据不是什么新鲜事了，这里讨论的令人激动的事情是如何用JWT建立一个可信的，不依赖session的RESTful服务。因为这种思路已经出现一段时间了，我接下来会用一个真实世界的类比来说明他是如何工作的：

想象一下，你出国度假，正准备回去，你正在通过海关，你说 - 你可以让我通过，我是一个良民。一切都没问题，但是你要如何证明你自己的说辞呢？大多数情况下，你会携带一个证明你的身份的护照。我们假设海关员工可以验证护照是否真的是你的国家的护照部门颁发的。护照被证明是合格的，他们就会让你通过。

现在，让我们看看这个象征JWT的故事里，各个元素对应着什么概念：

- **护照部门** - 发布JWT的认证服务
- **护照** - 经过护照部门签名的JWT。你的身份对于所有人来说都是可读的，但是有趣的部分可以用来验证他是否是真的。
- **公民身份** - 在JWT（你的护照）中的声明
- **海关** - 你的应用中用于验证JWT的安全层，验证成功才可授权访问受保护的资源。在这个例子中就是 - 国家
- **国家** - 你提供的资源（比如API）

## 看啊，没有session！

In very simple terms, JWT are cool because you don't need to keep session data on the server in order to authenticate the user. The workflow goes like so:

*   The user calls authentication service, usually sending username and password.
*   The authentication service responds with a signed JWT, which says who the user is.
*   The user requests access to a secured service sending the token back.
*   Security layer checks the signature on the token and if it's genuine the access is granted.

Let's think for a moment about the consequences.

### No session storage

No sessions means no session storage. Sounds like not much unless your applications needs to scale horizontally. If your application is run on multiple servers then sharing the session data becomes a burden. You either need a specialised server just for session storage or shared disk space or sticky sessions on the load balancer. None of that is needed when you don't use sessions.

### No garbage collection for sessions

Usually sessions need to be expired and garbage collected. JWT can carry its own expiry date along with the user data. Therefore the security layer checking JWT's authenticity can also check the expiry time and simply refuse access.

### Truly RESTful services

Only without sessions you can create truly RESTful services, as they are supposed to be [stateless](https://en.wikipedia.org/wiki/Representational_state_transfer#Stateless). JWT is small so it can be sent with each request, just like a session cookie. Unlike the session cookie however, it does not point to any data stored on the server, JWT has the data.

## How does JWT look, exactly?

There is one thing we need get straight before we dive in any further. JWT is not a thing of its own. It is a type of either [JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515) or [JSON Web Encryption (JWE)](https://tools.ietf.org/html/rfc7516). Definition time:

> The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure

The former gives us just the signature and the data it contains (or the "claims" as they call it in JWT nomenclature) is readable to anyone. The latter offers encryption, so only someone with a key can decrypt it. The JWS implementation is much easier and the basic usage does not require encryption - after all if you have a key on the client you may as well leave the whole thing unencrypted. Therefore JWS is used in most cases and so I am going to focus on it here.

### So what goes into the JWT/JWS?

*   **Header** - information about the signing algorithm, the type of payload (JWT) and so on in JSON format.
*   **Payload** - the actual data (or claims if you like) in JSON format.
*   **Signature** - well... the signature.

I will explain the details later on. For now let's analyse the basics.

Each part mentioned above (header, payload and signature) is base64url-encoded, then they are glued together with a `.` to form JWT. Here is how the implementation could look like:

```
var header = {  
        // The signing algorithm.
        "alg": "HS256",
        // The type (typ) property says it's "JWT",
        // because with JWS you can sign any type of data.
        "typ": "JWT"
    },
    // Base64 representation of the header object.
    headerB64 = btoa(JSON.stringify(header)),
    // The payload here is our JWT claims.
    payload = {
        "name": "John Doe",
        "admin": true
    },
    // Base64 representation of the payload object.
    payloadB64 = btoa(JSON.stringify(payload)),
    // The signature is calculated on the base64 representation
    // of the header and the payload.
    signature = signatureCreatingFunction(headerB64 + '.' + payloadB64),
    // Base64 representation of the signature.
    signatureB64 = btoa(signature),
    // Finally, the whole JWS - all base64 parts glued together with a '.'
    jwt = headerB64 + '.' + payloadB64 + '.' + signatureB64;

```

The resulting JWS looks neat and sweet and somewhat like this:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJhZG1pbiI6dHJ1ZX0.OLvs36KmqB9cmsUrMpUutfhV52_iSz4bQMYJjkI_TLQ  

```

You can play around with creating the tokens on [jwt.io](https://jwt.io/#debugger) website.

Quite an important thing is that the the signature is calculated for both the header and the payload in one go. Thus the authenticity of the header and the payload can be easily checked in one go as well:

```
[headerB64, payloadB64, signatureB64] = jwt.split('.');

if (atob(signatureB64) === signatureCreatingFunction(headerB64 + '.' + payloadB64) {  
    // good
} else
    // no good
}

```

### JWT header 中可以有什么参数？

其实，JWT header 叫做 JOSE header，JOSE 是 JSON Object Sigining and Encrytion 的缩写。JWS (JSON Web Sign) 和JWE (JSON Web Encryption) 也同样有这样的header，虽然每一种都有的稍不一样的标准参数集合 。下面的列表给出了JWS 的header中的标准参数。除了第一个（alg）之外，其他的参数都是可选的：

*   **alg** Algorithm 算法 (必须有)
*   **typ** Type (如果有的话，JWT header 中 Type 需要是`JWT`)
*   **kid** Key ID
*   **cty** Content Type
*   **jku** JWK Set URL
*   **jwk** JSON Web Key
*   **x5u** X.509 URL 
*   **x5c** X.509 Certificate Chain
*   **x5t** X.509 Certificate SHA-1 Thumbprint
*   **x5t#S256** X.509 Certificate SHA-256 Thumbprint
*   **crit** Critical

头两个参数最经常使用，因此标准的header 看起来有点像下面这个样子：

```
{
    "alg": "HS256",
    "typ": "JWT"
}

```

上面的第三个header参数，`kid` ，是出于安全因素的考虑。`cty` 则是只能在嵌套的JWT中使用（译者：参考一些[github代码(line:42-47)](https://github.com/luishdosreis/flasktaskr/blob/a1eddf5d5b629b8737a1956d4d46df84b69c8aa2/lib/python2.7/site-packages/jwt/tests/test_jwt.py) 如果是嵌套的JWT, 即JWT之后又JWT一次的，cty  是 `JWT` ）。剩下的你可以在[这里的标准说明](https://tools.ietf.org/html/rfc7515#section-4.1)中读到,我是觉得这些超出了本文范围。

#### `alg` (algorithm 算法)

`alg`参数的值可以是[JSON Web Algorithms (JWA)](https://tools.ietf.org/html/rfc7518#section-3.1) 中声明的任一种（是，我知道这又是一份标准说明），JWS 中注册的算法列表如下：

*   **HS256** - HMAC using SHA-256
*   **HS384** - HMAC using SHA-384
*   **HS512** - HMAC using SHA-512
*   **RS256** - RSASSA-PKCS1-v1_5 using SHA-256
*   **RS384** - RSASSA-PKCS1-v1_5 using SHA-384
*   **RS512** - RSASSA-PKCS1-v1_5 using SHA-512
*   **ES256** - ECDSA using P-256 and SHA-256
*   **ES384** - ECDSA using P-384 and SHA-384
*   **ES512** - ECDSA using P-521 and SHA-512
*   **PS256** - RSASSA-PSS using SHA-256 and MGF1 with SHA-256
*   **PS384** - RSASSA-PSS using SHA-384 and MGF1 with SHA-384
*   **PS512** - RSASSA-PSS using SHA-512 and MGF1 with SHA-512
*   **none** - No digital signature or MAC performed（不使用数字签名或MAC）

请留意最后一个，`none`,从安全的角度看是最值得关注的 。[它被用作降级攻击](https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/)（译者：15年的一篇文章，是当时JWT的一些实现上的严重漏洞，参考这个[360安全播报](http://bobao.360.cn/news/detail/1377.html)）. 它是如何攻击的呢？想象一个由攻击者构造出来的JWT，它在header里声明签名算法是`none`并发送过来请求验证。如果认证方（可信发布方）比较愚蠢，它会使用这个`alg`参数并授予请求者不应该有的权限。

原则上是，应用的安全层次上应该始终对header的`alg`参数持审慎态度，这就是`kid`参数便利的地方。


#### `typ` (type)

这个参数含义相当直白，如果明确知道这是一个JWT请求（因为应用根本就不会有其他类别），这个参数可以忽略掉。因此，它是一个可选参数。如果一定要有，值就应该是大写的`JWT`。

在某些情况下，如果应用接收非JWT请求和`JWT`，那么声明`typ`就非常重要，否则应用就疯掉了。

#### `kid` (key id)

如果你的应用的安全层只用一种算法来签名JWT请求，那么就不用担心`alg`参数了，因为你始终会用同样的key 和算法来检查token的完整性。但是，要是用了一系列不同的算法和key，就必须要能够确认token是哪个算出来的。

像前面那样，只依靠`alg`参数可能会导致一些麻烦。但是如果你的应用有一组`key－算法`对,并且每对都有一个名字或id，你就可以在把 key id加到header里，然后在`JWT`认证过程中就有更多的信息用来挑选算法了。这就是`kid`参数 － 你用来签名token的key的id。

id 可以是任意的，取决于你赋的值。最重要的是这个－你给出去的，所以你能够验证它。

#### `cty` (content type)

这份[RFC文档](https://tools.ietf.org/html/rfc7519#section-5.2) 说的非常清晰,这里我就直接引用了:

> 在正常情况下，即没有嵌套的签名或加密操作，**强烈不推荐**使用这个header参数（原文是 NOT RECOMMENDED）。而在那种使用了嵌套的签名或加密的情况下，这个header参数**必须**(原文是：MUST)要有。这里，这个值必须是`JWT`，表明这是一个嵌套的JWT。尽管媒体类型的名字不是大小写敏感的，但是还是**建议**用大写的字符`JWT`，以便兼容遗留代码。

### JWT 声明中可以有些啥？

"声明"这个词是否吓到你了？一开始确实吓到我了。我相信你也肯定念叨了几遍来熟悉它。简单的说，声明是`JWT`的核心，这就是我们如此关心，以至于要签名来验证的数据。它称作“声明”是因为它一般就是这样，客户端声明用户名、用户角色或者随便其他诸如此类的数据来请求授权，用于访问后续资源。

想起文章开始时说的有趣比喻吗？你的公民身份就是声明，而护照就是`JWT`

你可以添加任何你想要的声明，但这里也有一份[标准列表](https://tools.ietf.org/html/rfc7519#section-4.1)，在诸多实现中是被普遍认可的。 请留意它们中的任一个都是可选的而且其中大多数的处理方法都是每个应用特定的。

这是列表：

*   **exp** - Expiration Time
*   **nbf** - Not Before
*   **iat** - Issued At
*   **sub** - Subject
*   **iss** - Issuer
*   **aud** - Audience
*   **jti** - JWT ID


除了最后三个（`issuer`,`audience`和`JWT ID`）之外都不重要，最后三个通常用在更复杂的情形下。下面就一一介绍。

#### `exp` (expiration date) 过期时间

这个时间戳是token失效的时间。标准说明上说，为了允许处理token数据，`exp`声明的值“**一定**要晚于当前时间”。这也表明允许因为时钟漂移造成的延迟（可能几分钟）。

#### `nbf` (not before) 开始时间

这个时间戳是token开始生效的时间。标准说明上说，这个`nbf`声明的值，“**一定**要早于或等于当前时间”，以便处理token。这也表明允许因为时钟漂移造成的延迟（可能几分钟）。

#### `iat` (issued at) 颁发时间

token 生成的时间戳

#### `sub` (subject) 主题

标准说明上说，“是`JWT`上一个关于主题的普通陈述的声明”，主题声明必须是在颁发者上下文唯一的，或者全局唯一。这个`sub`声明可以用来确认用户的身份，比如[JIRA](https://developer.atlassian.com/static/connect/docs/latest/concepts/understanding-jwt.html#token-structure-claims)做的这样。

#### `iss` (issuer) 颁发者

用于辨别token颁发者的字符串值，如果字符串包含`:`，那它必须是一个URI，如果同一个安全层面上有很多颁发者而且应用需要辨别颁发者，`iss`就很有用了。比如[Salesforce](https://help.salesforce.com/HTViewHelpDoc?id=remoteaccess_oauth_jwt_flow.htm)（译者：竟然是多语言的文档）就需要使用 OAuth client_id 做为 `iss`的值。


#### `aud` (audience) 受众

用来辨别token的目标接受者的字符串或者字符串数组(多个接受者)。如果字符串包含`:`，就必须是一个URI。通常作为一个合法请求的资源的URI。
比如，在[OAuth](https://tools.ietf.org/html/rfc7523#section-3) ,受众就是授权的服务器。应用处理token必须核实正确的受众并拒绝其他受众的请求。


#### `jti` (JWT id) 

token 的唯一标志符。对每一个颁发的token，这个值必须是唯一的，即使有很多颁发者。`jti`
声明可以用作一次性token，而不能够重放。

## 在应用中使用JWT

在大部分场景下，浏览器客户端会在授权服务器上请求授权并拿到一个JWT作为返回。然后客户端把这个token以某种方式存下来（比如内存、本地存储等）
 and sends it back with every request for a protected resource. Usually the token is sent as a cookie or `Authorization` header in HTTP request:

```
GET /api/secured-resource HTTP/1.1  
Host: example.com  
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJhZG1pbiI6dHJ1ZX0.OLvs36KmqB9cmsUrMpUutfhV52_iSz4bQMYJjkI_TLQ  

```

The header method is preferred for security reasons - cookies would be susceptible to [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet) (Cross Site Request Forgery) unless CSRF tokens were used.

Secondly, the cookies can be sent back only to the same domain (or at most second level domain) they were issued from. If the authentication service resides on a different domain, cookies require much more wild creativeness.

### How to log out with JWT?

Because there is no session date stored on the service side, logging out cannot be performed by destroying the session. Therefore logging out is the client's responsibility - as soon as the client forgets the token it cannot be authorised any more and therefore can be considered logged out.

## Conclusion

I think JWTs are a very clever way of authorising without sessions. They allow for creating truly RESTful services with no state remembered on the service side, meaning no session storage is required either.

Unlike session cookies automatically sent by the browser to any URL matching the domain/path combination (let's be honest, it's just the domain in most cases), JWTs can be selectively sent only to the resources requiring authorisation.

The implementation is pretty simple, both on the client and on the server, especially that there are specialised [libraries](https://jwt.io/#libraries-io) for signing and verifying the tokens.

Thanks for reading!

If you like this article please share it. Your comments are very welcome!

